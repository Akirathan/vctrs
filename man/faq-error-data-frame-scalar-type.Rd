% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/faq-developer.R
\name{faq-error-data-frame-scalar-type}
\alias{faq-error-data-frame-scalar-type}
\title{FAQ - Why isn't my data frame subclass treated as a vector?}
\description{
The tidyverse is a bit stricter than base R regarding what kind of
objects are considered as vectors (see the \link[=faq-error-scalar-type]{user FAQ} about this topic). However, if you get an
“Input must be a vector” error with a data frame subclass, it probably
means that the data frame has not been properly constructed. The main
cause of these errors are data frames whose \emph{base class} is not
\code{"data.frame"}:\if{html}{\out{<div class="r">}}\preformatted{my_df <- data.frame(x = 1)
class(my_df) <- c("data.frame", "my_class")

vctrs::vec_assert(my_df)
#> Error: `my_df` must be a vector, not a `data.frame/my_class` object.
}\if{html}{\out{</div>}}

This is problematic as many tidyverse functions won’t work properly:\if{html}{\out{<div class="r">}}\preformatted{dplyr::slice(my_df, 1)
#> Warning: replacing previous import 'vctrs::data_frame' by 'tibble::data_frame'
#> when loading 'dplyr'
#> Error: Input must be a vector, not a `data.frame/my_class` object.
}\if{html}{\out{</div>}}

It is generally not appropriate to declare your class to be a superclass
of another class. We generally consider this undefined behaviour (UB).
To fix these errors, you can simply change the construction of your data
frame class so that \code{"data.frame"} is a base class:\if{html}{\out{<div class="r">}}\preformatted{class(my_df) <- c("my_class", "data.frame")

vctrs::vec_assert(my_df)

dplyr::slice(my_df, 1)
#>   x
#> 1 1
}\if{html}{\out{</div>}}
}
