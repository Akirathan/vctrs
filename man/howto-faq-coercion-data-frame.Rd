% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/faq-developer.R
\name{howto-faq-coercion-data-frame}
\alias{howto-faq-coercion-data-frame}
\title{FAQ - How to implement ptype2 and cast methods? (Data frames)}
\description{
This guide provides a practical recipe for implementing \code{vec_ptype2()}
and \code{vec_cast()} methods for coercions of data frame subclasses. Related
topics:
\itemize{
\item For an overview of the coercion mechanism in vctrs, see
\code{\link[=theory-faq-coercion]{?theory-faq-coercion}}.
\item For an example of implementing coercion methods for non-data-frame
vectors, see \code{\link[=howto-faq-coercion]{?howto-faq-coercion}}.
}

Coercion of data frames occurs when different data frame classes are
combined in some way. The two main methods of combination are currently
row-binding with \code{\link[=vec_rbind]{vec_rbind()}} and col-binding with
\code{\link[=vec_cbind]{vec_cbind()}} (which are in turn used by a number of
dplyr functions). These functions take multiple data frame inputs and
automatically coerce them to their common type.

vctrs is intentionally strict about the kind of automatic coercions that
are performed when combining inputs. For instance, it’s not clear what
combining rowwise data frame and a grouped data frame should return. In
this case, vctrs throws an incompatible type error because the user
needs to decide which type is appropriate for the task at hand.
\subsection{Parent methods}{

Most of the common type determination should be performed by the parent
class. In vctrs, double dispatch is implemented in such a way that you
need to call the methods for the parent class manually. For
\code{vec_ptype2()} this means you need to call \code{df_ptype2()} (for data frame
subclass) or \code{tib_ptype2()} (for tibble subclass). Similarly,
\code{df_cast()} and \code{tib_cast()} are the workhorses for \code{vec_cast()} methods
of subtypes of \code{data.frame} and \code{tbl_df}. These functions take the union
of the columns in \code{x} and \code{y}, and ensure shared columns have the same
type.

These functions are much less strict than \code{vec_ptype2()} and
\code{vec_cast()} as they accept any subclass of data frame as input. They
always return a \code{data.frame} or a \code{tbl_df}. Note that if you write
similar functions for your subclass (which should be rare), you’ll need
to export it so.
}

\subsection{A \code{data.table} example}{

This example is the actual implementation of vctrs coercion methods for
\code{data.table}.

We first create the \code{dt_ptype2()} and \code{dt_cast()} helpers. They wrap
around the parent methods \code{df_ptype2()} and \code{df_cast()}, and transform
the common type or converted input to a data table. You may want to
export these helpers if you expect other packages to derive from your
data frame class.

These helpers should always return data tables. To this end we use the
conversion generic \code{as.data.table()}. Depending on the tools available
for the particular class at hand, a constructor might be appropriate as
well.\if{html}{\out{<div class="r">}}\preformatted{dt_ptype2 <- function(x, y, ...) \{
  as.data.table(df_ptype2(x, y, ...))
\}
dt_cast <- function(x, to, ...) \{
  as.data.table(df_cast(x, to, ...))
\}
}\if{html}{\out{</div>}}

We start with the self-self method:\if{html}{\out{<div class="r">}}\preformatted{#' @export
vec_ptype2.data.table.data.table <- function(x, y, ...) \{
  dt_ptype2(x, y, ...)
\}
}\if{html}{\out{</div>}}

Between a data frame and a data table, we consider the richer type to be
data table. This is not made based on the coverage of each data
structures, but on the idea that data tables have richer behaviour.
Since data tables are the richer type, we call \code{dt_type2()} from the
\code{vec_ptype2()} method. It always returns a data table, no matter the
order of arguments:\if{html}{\out{<div class="r">}}\preformatted{#' @export
vec_ptype2.data.table.data.frame <- function(x, y, ...) \{
  dt_ptype2(x, y, ...)
\}
#' @export
vec_ptype2.data.frame.data.table <- function(x, y, ...) \{
  dt_ptype2(x, y, ...)
\}
}\if{html}{\out{</div>}}

The \code{vec_cast()} methods follow the same pattern, but note how the
method for coercing to data frame uses \code{df_cast()} rather than
\code{dt_cast()}:\if{html}{\out{<div class="r">}}\preformatted{#' @export
vec_cast.data.table.data.table <- function(x, to, ...) \{
  dt_cast(x, to, ...)
\}
#' @export
vec_cast.data.table.data.frame <- function(x, to, ...) \{
  dt_cast(x, to, ...)
\}
#' @export
vec_cast.data.frame.data.table <- function(x, to, ...) \{
  df_cast(x, to, ...)
\}
}\if{html}{\out{</div>}}

With these methods vctrs is now able to combine data tables with data
frames:\if{html}{\out{<div class="r">}}\preformatted{vec_cbind(data.frame(x = 1:3), data.table(y = "foo"))
#>    x   y
#> 1: 1 foo
#> 2: 2 foo
#> 3: 3 foo
}\if{html}{\out{</div>}}
}
}
