
```{r, child = "../setup.Rmd", include = FALSE}
```

This guide provides a practical recipe for implementing `vec_ptype2()` and `vec_cast()` methods for coercions of data frame subclasses. Related topics:

- For an overview of the coercion mechanism in vctrs, see [`?theory-faq-coercion`][theory-faq-coercion].

- For an example of implementing coercion methods for non-data-frame vectors, see [`?howto-faq-coercion`][howto-faq-coercion].

Coercion of data frames occurs when different data frame classes are combined in some way. The two main methods of combination are currently row-binding with [vec_rbind()] and col-binding with [vec_cbind()]. These functions take multiple data frame inputs and automatically coerce them their common type.

vctrs is intentionally strict about the kind of automatic coercions that are performed when combining inputs. For instance, it doesn't make sense to combine a rowwise data frame and a grouped data frame. In this case, vctrs throws an incompatible type error because the user should be the one that does the work of converting the data frames to the format makes the most sense for the task at hand.


## Parent methods

Most of the common type determination should be performed by the parent methods. In vctrs, double dispatch is implemented in such a way in vctrs that you need to call your parent method manually. For `vec_ptype2()` this is typically `df_ptype2()` for a data frame subclass or `tib_ptype2()` if you have a tibble subclass. Similarly, `df_cast()` and `tib_cast()` are the workhorses for `vec_cast()` methods of subtypes of `data.frame` and `tbl_df`.

These functions are much less strict than `vec_ptype2()` and `vec_cast()` as they accept any subclass of data frame as input. They always return a `data.frame` or a `tbl_df`. They should be explicitly exported by packages to allow creating subtypes.


## A `data.table` example

```{r, include = FALSE}
delayedAssign("as.data.table", {
  if (is_installed("data.table")) {
    env_get(ns_env("data.table"), "as.data.table")
  } else {
    function(...) abort("`data.table` must be installed.")
  }
})
delayedAssign("data.table", {
  if (is_installed("data.table")) {
    env_get(ns_env("data.table"), "data.table")
  } else {
    function(...) abort("`data.table` must be installed.")
  }
})
```

This example is the actual implementation of vctrs coercion methods for `data.table`.

We first create the `dt_ptype2()` and `dt_cast()` helpers. They wrap around the parent methods `df_ptype2()` and `df_cast()`, and transform the common type or converted input to a data table. You may want to export these helpers if you expect other packages to derive from your data frame class.

These helpers should always return data tables. To this end we use the conversion generic `as.data.table()`. Depending on the tools available for the particular class at hand, a constructor might be appropriate as well.

```{r}
dt_ptype2 <- function(x, y, ...) {
  as.data.table(df_ptype2(x, y, ...))
}
dt_cast <- function(x, to, ...) {
  as.data.table(df_cast(x, to, ...))
}
```

Between a data frame and a data table, we consider the richer type to be data table. This is not made based on the coverage of each data structures, but on the idea that data tables have richer behaviour. Since data tables are the richer type, we call `dt_type2()` from the `vec_ptype2()` method. It always returns a data table, no matter the order of arguments:

```{r}
#' @export
vec_ptype2.data.table.data.frame <- function(x, y, ...) {
  dt_ptype2(x, y, ...)
}
#' @export
vec_ptype2.data.frame.data.table <- function(x, y, ...) {
  dt_ptype2(x, y, ...)
}
```

The `vec_cast()` methods follow the same pattern:

```{r}
#' @export
vec_cast.data.table.data.frame <- function(x, to, ...) {
  dt_cast(x, to, ...)
}
#' @export
vec_cast.data.frame.data.table <- function(x, to, ...) {
  df_cast(x, to, ...)
}
```

With these methods vctrs is now able to combine data tables with data frames:

```{r}
vec_cbind(data.frame(x = 1:3), data.table(y = "foo"))
```
